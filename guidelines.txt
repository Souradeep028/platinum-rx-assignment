The assignment outlines the design and implementation of a Payment Service for dynamic routing across multiple payment gateways. Hereâ€™s a breakdown of what each API is supposed to do:


ğŸ”„ 1. Initiate Transaction API

Endpoint: POST /transactions/initiate

Input (Request Payload):

{
  "order_id": "ORD123",
  "amount": 499.0,
  "payment_instrument": {
    "type": "card",
    "card_number": "****",
    "expiry": "MM/YY"
    // ... other card details
  }
}

Expected Behavior:
	â€¢	Use routing logic that considers:
	â€¢	Load distribution (based on configured percentage weights)
	â€¢	Gateway health (disable if success rate < threshold)
	â€¢	Select a payment gateway accordingly.
	â€¢	Simulate or mock the actual payment call (no real integration needed).
	â€¢	Store the transaction locally with:
	â€¢	order_id, amount, selected gateway, and initial status = pending.

Output (Response):
	â€¢	Return the created transaction entity including:
	â€¢	Chosen gateway
	â€¢	Status = pending


ğŸ“¥ 2. Callback API

Endpoint: POST /transactions/callback

Input (Request Payload):

{
  "order_id": "ORD123",
  "status": "success" | "failure",
  "gateway": "razorpay",
  "reason": "Customer Cancelled" // optional
}

Expected Behavior:
	â€¢	Update the stored transactionâ€™s status to success or failure.
	â€¢	Maintain gateway performance stats:
	â€¢	Track number of successes and failures over time.
	â€¢	If a gatewayâ€™s failure rate > threshold (e.g., 10%) within 15 minutes:
	â€¢	Mark the gateway as â€œunhealthyâ€
	â€¢	Exclude it from routing decisions for next 30 minutes

âœ… Functional Expectations:
	â€¢	Local or in-memory persistence of:
            -Transactions
	â€¢	Gateway health & routing weights
	â€¢	Resilient and fault-tolerant routing
	â€¢	Logging for:
		    -Gateway selection
		    -Status updates
		    -Health state changes
    â€¢   Working implementation with clean, modular code

ğŸ“ Bonus Points:
	â€¢	Host with Docker (e.g., Docker Compose)
	â€¢	Basic test coverage (unit or integration)