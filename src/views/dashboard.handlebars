<!-- Gateway Health Cards -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h4 class="mb-0">
                    <i class="fas fa-heartbeat me-2"></i>
                    Gateway Health Status
                </h4>
            </div>
            <div class="card-body">
                {{> gateway-cards}}
            </div>
        </div>
    </div>
</div>

<!-- API Playground -->
<div class="row mb-4">
    <div class="col-12">
        {{> api-playground}}
    </div>
</div>

<!-- Pending Transactions -->
<div class="row mb-4">
    <div class="col-12">
        {{> pending-transactions}}
    </div>
</div>

<!-- Completed Transactions -->
<div class="row mb-4">
    <div class="col-12">
        {{> completed-transactions}}
    </div>
</div>

<style>
/* Custom styles for scrollable tables */
.table-responsive {
    border-radius: 0.375rem;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.table-responsive::-webkit-scrollbar {
    width: 8px;
}

.table-responsive::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

.table-responsive::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

.table-responsive::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

/* Fixed table headers */
.table-responsive {
    position: relative;
}

.table-responsive .table {
    margin-bottom: 0;
}

.table-responsive .table thead {
    position: sticky;
    top: 0;
    z-index: 100;
}

.table-responsive .table thead th {
    background-color: #212529 !important;
    border-bottom: 2px solid #dee2e6;
    position: sticky;
    top: 0;
    z-index: 100;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    white-space: nowrap;
}

/* Add some spacing for better readability */
.table tbody tr:hover {
    background-color: rgba(0, 123, 255, 0.1);
}

/* Ensure proper spacing in scrollable tables */
.table-responsive .table tbody tr:last-child td {
    border-bottom: none;
}

/* Add smooth transitions for better UX */
.table tbody tr {
    transition: background-color 0.2s ease;
}

/* Ensure buttons in scrollable tables are properly sized */
.table-responsive .btn-sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.875rem;
}

/* Additional styles for better sticky header appearance */
.table-responsive .table thead th:first-child {
    border-top-left-radius: 0.375rem;
}

.table-responsive .table thead th:last-child {
    border-top-right-radius: 0.375rem;
}

/* Ensure the sticky header has proper borders */
.table-responsive .table thead th {
    border-top: none;
    border-left: 1px solid #dee2e6;
    border-right: 1px solid #dee2e6;
}

.table-responsive .table thead th:first-child {
    border-left: none;
}

.table-responsive .table thead th:last-child {
    border-right: none;
}

/* Additional fixes for sticky headers */
.table-responsive {
    overflow: auto;
    max-height: 400px;
    border-radius: 0.375rem;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
}

.table-responsive .table {
    width: 100%;
    margin-bottom: 0;
}

/* Ensure cards are not scrollable */
.card {
    overflow: visible;
    border: 1px solid rgba(0, 0, 0, 0.125);
    border-radius: 0.375rem;
    box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
}

.card-body {
    overflow: visible;
    padding: 1rem;
}

/* Ensure table containers are clearly scrollable */
.table-responsive {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    background-color: #fff;
    position: relative;
}

/* Add subtle scroll indicator */
.table-responsive::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid #dee2e6;
    border-bottom: 8px solid transparent;
    opacity: 0.5;
    pointer-events: none;
}

/* Ensure sticky headers work in all browsers */
.table-responsive .table thead th {
    position: -webkit-sticky;
    position: sticky;
    top: 0;
    background-color: #212529 !important;
    color: white !important;
    z-index: 100;
}

/* Fix for table body scrolling */
.table-responsive .table tbody {
    position: relative;
}

/* Ensure proper spacing when scrolling */
.table-responsive .table tbody tr:first-child td {
    border-top: none;
}
</style>

<script>
// Global variables for tracking
let gatewayLogs = [];
let currentTransaction = null;

// Handle transaction form submission
document.getElementById('transactionForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    console.log('Form submitted, preventing default');
    
    // Clear any previous response and show loading state
    const responseArea = document.getElementById('responseArea');
    const responsePlaceholder = document.getElementById('responsePlaceholder');
    responseArea.style.display = 'none';
    responsePlaceholder.style.display = 'block';
    responsePlaceholder.innerHTML = `
        <i class="fas fa-spinner fa-spin fa-2x mb-3"></i>
        <p>Processing transaction...</p>
    `;
    
    const formData = new FormData(this);
    const paymentInstrumentType = formData.get('payment_instrument');
    
    console.log('Payment instrument type:', paymentInstrumentType);
    console.log('Form data:', {
        order_id: formData.get('order_id'),
        amount: formData.get('amount'),
        payment_instrument: paymentInstrumentType
    });
    
    // Build the payload based on payment instrument type
    let payload = {
        order_id: formData.get('order_id'),
        amount: parseFloat(formData.get('amount')),
        payment_instrument: {
            type: paymentInstrumentType
        }
    };
    
    // Add specific fields based on payment instrument type
    if (paymentInstrumentType === 'card') {
        payload.payment_instrument.card_number = '4111111111111111';
        payload.payment_instrument.expiry = '12/25';
        payload.payment_instrument.cvv = '123';
        payload.payment_instrument.card_holder_name = 'Test User';
    } else if (paymentInstrumentType === 'upi') {
        payload.payment_instrument.upi_id = 'testuser@bank';
    } else if (paymentInstrumentType === 'netbanking') {
        payload.payment_instrument.bank_code = 'HDFC';
    }
    
    console.log('Sending payload:', JSON.stringify(payload, null, 2));
    
    try {
        console.log('Making API request to /transactions/initiate');
        const response = await axios.post('/transactions/initiate', payload);
        console.log('API response:', response.data);
        displayResponse(response.data);
        addGatewayLog(`Transaction initiated with gateway: ${response.data.selected_gateway}`);
        currentTransaction = response.data;
        
        // Ensure placeholder is hidden
        const responsePlaceholder = document.getElementById('responsePlaceholder');
        if (responsePlaceholder) {
            responsePlaceholder.style.display = 'none';
        }
        
        // Double-check after a short delay
        setTimeout(() => {
            if (responsePlaceholder && responsePlaceholder.style.display !== 'none') {
                console.warn('Placeholder still visible after success, forcing hide');
                responsePlaceholder.style.display = 'none';
            }
        }, 200);
        
        // Generate new order ID for next transaction
        setTimeout(() => {
            generateNewOrderId();
        }, 1500);
        
        // Refresh tables after a short delay
        setTimeout(() => {
            refreshTables();
        }, 1000);
        
    } catch (error) {
        console.error('API request failed:', error);
        console.error('Error response:', error.response?.data);
        
        // Handle specific error cases
        let errorMessage = 'Failed to initiate transaction';
        let errorDetails = error.response?.data || error.message;
        
        if (error.response?.status === 503 && error.response?.data?.error === 'All gateways are unhealthy') {
            errorMessage = 'All payment gateways are currently unavailable';
            addGatewayLog('ERROR: All gateways are unhealthy - no payment gateways available');
            
            // Show a more user-friendly message
            displayResponse({
                error: errorMessage,
                message: 'No payment gateways are currently available. Please try again later.',
                gateway_stats: error.response?.data?.gateway_stats,
                order_id: error.response?.data?.order_id,
                request_id: error.response?.data?.request_id
            });
        } else {
            displayResponse({
                error: errorMessage,
                details: errorDetails
            });
        }
        
        // Ensure placeholder is hidden even for errors
        const responsePlaceholder = document.getElementById('responsePlaceholder');
        if (responsePlaceholder) {
            responsePlaceholder.style.display = 'none';
        }
        
        // Double-check after a short delay
        setTimeout(() => {
            if (responsePlaceholder && responsePlaceholder.style.display !== 'none') {
                console.warn('Placeholder still visible after error, forcing hide');
                responsePlaceholder.style.display = 'none';
            }
        }, 200);
    }
});

// Handle bulk transaction form submission
document.getElementById('bulkTransactionForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    console.log('Bulk transaction form submitted');
    
    const formData = new FormData(this);
    const count = parseInt(formData.get('bulk_count'));
    const amount = parseFloat(formData.get('bulk_amount'));
    const paymentInstrumentType = formData.get('bulk_payment_instrument');
    
    if (count < 1 || count > 100) {
        alert('Please enter a valid number of transactions (1-100)');
        return;
    }
    
    // Show progress
    const progressDiv = document.getElementById('bulkProgress');
    const progressBar = document.getElementById('bulkProgressBar');
    const progressText = document.getElementById('bulkProgressText');
    const progressCount = document.getElementById('bulkProgressCount');
    const submitBtn = document.getElementById('bulkSubmitBtn');
    const resultsDiv = document.getElementById('bulkResults');
    const resultsContent = document.getElementById('bulkResultsContent');
    
    progressDiv.style.display = 'block';
    resultsDiv.style.display = 'none';
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Generating...';
    
    const results = {
        successful: 0,
        failed: 0,
        total: count,
        transactions: []
    };
    
    // Process transactions in batches to avoid overwhelming the server
    const batchSize = 5;
    const batches = Math.ceil(count / batchSize);
    
    for (let batch = 0; batch < batches; batch++) {
        const batchStart = batch * batchSize;
        const batchEnd = Math.min(batchStart + batchSize, count);
        const batchCount = batchEnd - batchStart;
        
        // Process batch
        const batchPromises = [];
        for (let i = 0; i < batchCount; i++) {
            const transactionIndex = batchStart + i;
            const orderId = generateRandomOrderId();
            
            // Build payload for this transaction
            let payload = {
                order_id: orderId,
                amount: amount,
                payment_instrument: {
                    type: paymentInstrumentType
                }
            };
            
            // Add specific fields based on payment instrument type
            if (paymentInstrumentType === 'card') {
                payload.payment_instrument.card_number = '4111111111111111';
                payload.payment_instrument.expiry = '12/25';
                payload.payment_instrument.cvv = '123';
                payload.payment_instrument.card_holder_name = 'Test User';
            } else if (paymentInstrumentType === 'upi') {
                payload.payment_instrument.upi_id = 'testuser@bank';
            } else if (paymentInstrumentType === 'netbanking') {
                payload.payment_instrument.bank_code = 'HDFC';
            }
            
            // Add delay between requests to avoid rate limiting
            const delay = i * 200; // 200ms delay between requests in batch
            const promise = new Promise(resolve => {
                setTimeout(async () => {
                    try {
                        const response = await axios.post('/transactions/initiate', payload);
                        results.successful++;
                        results.transactions.push({
                            order_id: orderId,
                            status: 'success',
                            gateway: response.data.selected_gateway,
                            response: response.data
                        });
                        addGatewayLog(`Bulk transaction ${transactionIndex + 1}/${count}: ${orderId} initiated with gateway: ${response.data.selected_gateway}`);
                    } catch (error) {
                        results.failed++;
                        results.transactions.push({
                            order_id: orderId,
                            status: 'failed',
                            error: error.response?.data?.error || error.message
                        });
                        addGatewayLog(`Bulk transaction ${transactionIndex + 1}/${count}: ${orderId} failed - ${error.response?.data?.error || error.message}`);
                    }
                    resolve();
                }, delay);
            });
            
            batchPromises.push(promise);
        }
        
        // Wait for batch to complete
        await Promise.all(batchPromises);
        
        // Update progress
        const progress = ((batch + 1) * batchSize / count) * 100;
        progressBar.style.width = `${Math.min(progress, 100)}%`;
        progressText.textContent = `Processing batch ${batch + 1}/${batches}`;
        progressCount.textContent = `${Math.min((batch + 1) * batchSize, count)} / ${count}`;
    }
    
    // Hide progress and show results
    progressDiv.style.display = 'none';
    submitBtn.disabled = false;
    submitBtn.innerHTML = '<i class="fas fa-rocket me-2"></i>Generate Bulk Transactions';
    
    // Show appropriate completion alert based on results
    if (results.failed === 0) {
        alert(`✅ Bulk transaction generation completed successfully! All ${results.successful} transactions were successful.`);
    } else if (results.successful === 0) {
        alert(`❌ Bulk transaction generation failed! All ${results.failed} transactions failed. Please check gateway health and try again.`);
    } else {
        alert(`⚠️ Bulk transaction generation completed with mixed results: ${results.successful} successful, ${results.failed} failed out of ${results.total} total.`);
    }
    
    // Hide the results div
    resultsDiv.style.display = 'none';
    
    // Refresh tables after bulk operation
    setTimeout(() => {
        refreshTables();
    }, 1000);
    
    addGatewayLog(`Bulk transaction generation completed: ${results.successful} successful, ${results.failed} failed out of ${results.total} total`);
});

// Generate random order ID
function generateRandomOrderId() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    return `BULK_${timestamp}_${random}`;
}

// Generate unique order ID for single transactions
function generateUniqueOrderId() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);
    return `ORD_${timestamp}_${random}`;
}

// Generate new order ID button function
function generateNewOrderId() {
    const orderIdField = document.getElementById('orderId');
    if (orderIdField) {
        orderIdField.value = generateUniqueOrderId();
    }
}

// Reset form to defaults
function resetFormToDefaults() {
    const orderIdField = document.getElementById('orderId');
    const amountField = document.getElementById('amount');
    const paymentInstrumentField = document.getElementById('paymentInstrument');
    
    if (orderIdField) {
        orderIdField.value = generateUniqueOrderId();
    }
    if (amountField) {
        amountField.value = '100.00';
    }
    if (paymentInstrumentField) {
        paymentInstrumentField.value = 'card';
    }
}

// Display API response
function displayResponse(data) {
    const responseArea = document.getElementById('responseArea');
    const responseContent = document.getElementById('responseContent');
    const responsePlaceholder = document.getElementById('responsePlaceholder');
    
    console.log('Displaying response:', data);
    console.log('Response area element:', responseArea);
    console.log('Response placeholder element:', responsePlaceholder);
    
    if (!responseArea || !responseContent || !responsePlaceholder) {
        console.error('One or more response elements not found:', {
            responseArea: !!responseArea,
            responseContent: !!responseContent,
            responsePlaceholder: !!responsePlaceholder
        });
        return;
    }
    
    responseContent.textContent = JSON.stringify(data, null, 2);
    responseArea.style.display = 'block';
    responsePlaceholder.style.display = 'none';
    
    // Double-check that placeholder is hidden
    setTimeout(() => {
        if (responsePlaceholder.style.display !== 'none') {
            console.warn('Placeholder still visible, forcing hide');
            responsePlaceholder.style.display = 'none';
        }
    }, 100);
}

// Reset response area to show placeholder
function resetResponseArea() {
    const responseArea = document.getElementById('responseArea');
    const responsePlaceholder = document.getElementById('responsePlaceholder');
    
    responseArea.style.display = 'none';
    responsePlaceholder.style.display = 'block';
    responsePlaceholder.innerHTML = `
        <i class="fas fa-arrow-left fa-2x mb-3"></i>
        <p>Response will appear here after initiating a transaction</p>
    `;
}

// Clear response area completely
function clearResponseArea() {
    const responseArea = document.getElementById('responseArea');
    const responseContent = document.getElementById('responseContent');
    const responsePlaceholder = document.getElementById('responsePlaceholder');
    
    responseContent.textContent = '';
    responseArea.style.display = 'none';
    responsePlaceholder.style.display = 'block';
    responsePlaceholder.innerHTML = `
        <i class="fas fa-arrow-left fa-2x mb-3"></i>
        <p>Response will appear here after initiating a transaction</p>
    `;
}

// Add gateway selection log
function addGatewayLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    
    // Add terminal-style prefixes based on message content
    let formattedMessage = message;
    
    // Check for specific patterns to avoid false positives
    const isBulkCompletion = message.toLowerCase().includes('bulk transaction generation completed');
    const hasFailedCount = message.toLowerCase().includes('failed') && message.toLowerCase().includes('0 failed');
    
    // Check if bulk completion had any successful transactions
    const bulkCompletionWithFailures = isBulkCompletion && 
                                      message.toLowerCase().includes('0 successful') && 
                                      message.toLowerCase().includes('failed');
    
    const isActualError = message.toLowerCase().includes('error') || 
                          (message.toLowerCase().includes('failed') && !hasFailedCount && !isBulkCompletion) ||
                          message.toLowerCase().includes('unhealthy') ||
                          bulkCompletionWithFailures;
    
    if (isActualError) {
        formattedMessage = `ERROR: ${message}`;
    } else if (message.toLowerCase().includes('success') || message.toLowerCase().includes('healthy') || (isBulkCompletion && !bulkCompletionWithFailures)) {
        formattedMessage = `SUCCESS: ${message}`;
    } else if (message.toLowerCase().includes('callback')) {
        formattedMessage = `CALLBACK: ${message}`;
    } else if (message.toLowerCase().includes('health check')) {
        formattedMessage = `HEALTH: ${message}`;
    } else {
        formattedMessage = `INFO: ${message}`;
    }
    
    const logEntry = {
        timestamp: timestamp,
        message: formattedMessage
    };
    
    gatewayLogs.unshift(logEntry);
    if (gatewayLogs.length > 10) {
        gatewayLogs = gatewayLogs.slice(0, 10);
    }
    
    updateGatewayLogs();
}

// Update gateway logs display
function updateGatewayLogs() {
    const logsContainer = document.getElementById('gatewayLogs');
    
    if (gatewayLogs.length === 0) {
        logsContainer.innerHTML = `
            <div style="color: #888; text-align: center; padding: 20px; font-family: 'JetBrains Mono', monospace;">
                <i class="fas fa-terminal me-2"></i>
                Gateway selection logs will appear here
            </div>
        `;
        return;
    }
    
    logsContainer.innerHTML = gatewayLogs.map((log, index) => {
        const timestamp = log.timestamp;
        const message = log.message;
        
        // More precise error detection
        const isBulkCompletion = message.toLowerCase().includes('bulk transaction generation completed');
        const bulkCompletionWithFailures = isBulkCompletion && 
                                          message.toLowerCase().includes('0 successful') && 
                                          message.toLowerCase().includes('failed');
        
        const isError = message.toLowerCase().includes('error') || 
                       (message.toLowerCase().includes('failed') && 
                        !message.toLowerCase().includes('0 failed') && 
                        !isBulkCompletion) ||
                       message.toLowerCase().includes('unhealthy') ||
                       bulkCompletionWithFailures;
        
        const isSuccess = message.toLowerCase().includes('success') || 
                         message.toLowerCase().includes('healthy') ||
                         (isBulkCompletion && !bulkCompletionWithFailures);
        
        let color = '#e0e0e0'; // default
        if (isError) color = '#ef4444'; // red for errors
        else if (isSuccess) color = '#10b981'; // green for success
        
        return `
            <div class="log-entry">
                <span style="color: #888; font-size: 0.75rem;">[${timestamp}]</span>
                <span style="color: ${color}; margin-left: 8px;">${message}</span>
            </div>
        `;
    }).join('');
}

// Clear gateway logs
function clearGatewayLogs() {
    gatewayLogs = [];
    updateGatewayLogs();
    console.log('Gateway logs cleared');
}

// Trigger callback for pending transaction
async function triggerCallback(orderId, status, gateway) {
    console.log('Triggering callback for:', { orderId, status, gateway });
    
    const payload = {
        order_id: orderId,
        status: status,
        gateway: gateway,
        reason: status === 'success' ? 'Payment processed successfully' : 'Payment failed'
    };
    
    try {
        console.log('Making callback API request:', payload);
        const response = await axios.post('/transactions/callback', payload);
        console.log('Callback API response:', response.data);
        addGatewayLog(`Callback triggered for ${orderId}: ${status}`);
        
        // Check gateway health after callback
        await checkGatewayHealth();
        
        // Refresh tables after callback
        setTimeout(() => {
            refreshTables();
        }, 500);
        
    } catch (error) {
        console.error('Callback error:', error);
        console.error('Callback error response:', error.response?.data);
        alert(`Failed to trigger callback: ${error.response?.data?.error || error.message}`);
    }
}

// Trigger bulk success for all pending transactions
async function triggerBulkSuccess() {
    if (!confirm('Are you sure you want to mark all pending transactions as successful?')) {
        return;
    }
    
    try {
        console.log('Triggering bulk success for all pending transactions');
        const response = await axios.post('/transactions/bulk-success');
        console.log('Bulk success API response:', response.data);
        
        addGatewayLog(`Bulk success operation completed: ${response.data.processed_count} transactions processed`);
        
        // Show results if available
        if (response.data.results && response.data.results.length > 0) {
            const successful = response.data.results.filter(r => r.status === 'success').length;
            const failed = response.data.results.filter(r => r.status === 'error').length;
            addGatewayLog(`Bulk success results: ${successful} successful, ${failed} errors`);
        }
        
        // Check gateway health after bulk operation
        await checkGatewayHealth();
        
        // Refresh tables after bulk operation
        setTimeout(() => {
            refreshTables();
        }, 500);
        
    } catch (error) {
        console.error('Bulk success error:', error);
        console.error('Bulk success error response:', error.response?.data);
        alert(`Failed to trigger bulk success: ${error.response?.data?.error || error.message}`);
    }
}

// Trigger bulk failure for all pending transactions
async function triggerBulkFailure() {
    if (!confirm('Are you sure you want to mark all pending transactions as failed?')) {
        return;
    }
    
    try {
        console.log('Triggering bulk failure for all pending transactions');
        const response = await axios.post('/transactions/bulk-failure');
        console.log('Bulk failure API response:', response.data);
        
        addGatewayLog(`Bulk failure operation completed: ${response.data.processed_count} transactions processed`);
        
        // Show results if available
        if (response.data.results && response.data.results.length > 0) {
            const successful = response.data.results.filter(r => r.status === 'failure').length;
            const failed = response.data.results.filter(r => r.status === 'error').length;
            addGatewayLog(`Bulk failure results: ${successful} failed, ${failed} errors`);
        }
        
        // Check gateway health after bulk operation
        await checkGatewayHealth();
        
        // Refresh tables after bulk operation
        setTimeout(() => {
            refreshTables();
        }, 500);
        
    } catch (error) {
        console.error('Bulk failure error:', error);
        console.error('Bulk failure error response:', error.response?.data);
        alert(`Failed to trigger bulk failure: ${error.response?.data?.error || error.message}`);
    }
}

// Update bulk operation button states
function updateBulkButtonStates(hasPendingTransactions) {
    const bulkSuccessBtn = document.getElementById('bulkSuccessBtn');
    const bulkFailureBtn = document.getElementById('bulkFailureBtn');
    
    if (bulkSuccessBtn && bulkFailureBtn) {
        bulkSuccessBtn.disabled = !hasPendingTransactions;
        bulkFailureBtn.disabled = !hasPendingTransactions;
    }
}

// Check gateway health
async function checkGatewayHealth() {
    try {
        console.log('Checking gateway health...');
        const response = await axios.get('/gateway/health');
        console.log('Gateway health response:', response.data);
        
        if (response.data.gateways) {
            const gatewayHealth = response.data.gateways;
            addGatewayLog(`Gateway health check completed - ${Object.keys(gatewayHealth).length} gateways monitored`);
            
            // Track unhealthy gateways for alert
            const unhealthyGateways = [];
            
            // Log individual gateway status
            Object.entries(gatewayHealth).forEach(([gatewayName, gateway]) => {
                const status = gateway.is_healthy ? 'healthy' : 'unhealthy';
                const successRate = gateway.success_rate ? ` (${(gateway.success_rate * 100).toFixed(1)}% success)` : '';
                addGatewayLog(`${gatewayName}: ${status}${successRate}`);
                
                if (!gateway.is_healthy) {
                    unhealthyGateways.push(gatewayName);
                }
            });
            
            // Show alert for unhealthy gateways
            if (unhealthyGateways.length > 0) {
                if (unhealthyGateways.length === Object.keys(gatewayHealth).length) {
                    alert(`❌ All gateways are unhealthy: ${unhealthyGateways.join(', ')}. Payment processing may be affected.`);
                } else {
                    alert(`⚠️ Some gateways are unhealthy: ${unhealthyGateways.join(', ')}. Payment processing may be degraded.`);
                }
            }
            
            // Update gateway cards with fresh data
            updateGatewayCards(gatewayHealth);
        }
        
    } catch (error) {
        console.error('Failed to check gateway health:', error);
        addGatewayLog(`Gateway health check failed: ${error.message}`);
    }
}

// Refresh transaction tables and gateway stats
async function refreshTables() {
    try {
        console.log('Refreshing transaction tables and gateway stats...');
        
        // Get transaction data
        const transactionResponse = await axios.get('/transactions');
        console.log('Transactions API response:', transactionResponse.data);
        const transactionData = transactionResponse.data;
        
        // Get gateway stats
        const gatewayResponse = await axios.get('/gateway/stats');
        console.log('Gateway stats API response:', gatewayResponse.data);
        const gatewayData = gatewayResponse.data;
        
        // Update pending transactions
        updatePendingTransactionsTable(transactionData.transaction_stats.recent_transactions.filter(t => t.status === 'pending'));
        
        // Update completed transactions
        updateCompletedTransactionsTable(transactionData.transaction_stats.recent_transactions.filter(t => t.status !== 'pending'));
        
        // Update gateway cards
        updateGatewayCards(gatewayData.gateway_stats);
        
        // Ensure scrollable behavior is maintained after updates
        initializeScrollableTables();
        
        // Ensure sticky headers are properly applied
        applyStickyHeaders();
        
    } catch (error) {
        console.error('Failed to refresh tables:', error);
    }
}

// Helper function to apply sticky headers to all tables
function applyStickyHeaders() {
    const tableContainers = document.querySelectorAll('.table-responsive');
    tableContainers.forEach(container => {
        // Ensure only the table container is scrollable
        container.style.maxHeight = '400px';
        container.style.overflowY = 'auto';
        container.style.overflowX = 'auto';
        
        // Ensure the parent card is not scrollable
        const card = container.closest('.card');
        if (card) {
            card.style.overflow = 'visible';
        }
        
        const thead = container.querySelector('thead');
        if (thead) {
            thead.style.position = 'sticky';
            thead.style.top = '0';
            thead.style.zIndex = '100';
            
            const thElements = thead.querySelectorAll('th');
            thElements.forEach(th => {
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.zIndex = '100';
                th.style.backgroundColor = '#212529';
                th.style.color = 'white';
                th.style.borderBottom = '2px solid #dee2e6';
            });
        }
    });
}

// Update pending transactions table
function updatePendingTransactionsTable(transactions) {
    const tbody = document.getElementById('pendingTransactionsTable');
    
    // Update button states based on pending transactions
    updateBulkButtonStates(transactions.length > 0);
    
    if (transactions.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center text-muted py-4">
                    <i class="fas fa-inbox fa-2x mb-3 d-block"></i>
                    No pending transactions
                </td>
            </tr>
        `;
        return;
    }
    
    // Create table rows with proper structure for scrollable table
    tbody.innerHTML = transactions.map(transaction => `
        <tr data-transaction-id="${transaction.transaction_id}" data-order-id="${transaction.order_id}">
            <td>${transaction.order_id}</td>
            <td>$${transaction.amount}</td>
            <td><span class="badge bg-info">${transaction.payment_instrument.type}</span></td>
            <td><span class="badge bg-secondary">${transaction.selected_gateway}</span></td>
            <td><span class="badge bg-warning">${transaction.status}</span></td>
            <td>${new Date(transaction.created_at).toLocaleString()}</td>
            <td>
                <button class="btn btn-success btn-sm btn-action callback-btn" 
                        data-order-id="${transaction.order_id}" 
                        data-status="success" 
                        data-gateway="${transaction.selected_gateway}">
                    <i class="fas fa-check me-1"></i>Success
                </button>
                <button class="btn btn-danger btn-sm btn-action callback-btn" 
                        data-order-id="${transaction.order_id}" 
                        data-status="failure" 
                        data-gateway="${transaction.selected_gateway}">
                    <i class="fas fa-times me-1"></i>Failure
                </button>
            </td>
        </tr>
    `).join('');
    
    // Ensure the table container maintains scrollable behavior
    const tableContainer = tbody.closest('.table-responsive');
    if (tableContainer) {
        tableContainer.style.maxHeight = '400px';
        tableContainer.style.overflowY = 'auto';
        tableContainer.style.overflowX = 'auto';
        
        // Ensure the parent card is not scrollable
        const card = tableContainer.closest('.card');
        if (card) {
            card.style.overflow = 'visible';
        }
        
        // Re-apply sticky headers after content update
        const thead = tableContainer.querySelector('thead');
        if (thead) {
            thead.style.position = 'sticky';
            thead.style.top = '0';
            thead.style.zIndex = '100';
            
            const thElements = thead.querySelectorAll('th');
            thElements.forEach(th => {
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.zIndex = '100';
                th.style.backgroundColor = '#212529';
                th.style.color = 'white';
            });
        }
    }
}

// Update completed transactions table
function updateCompletedTransactionsTable(transactions) {
    const tbody = document.getElementById('completedTransactionsTable');
    
    if (transactions.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center text-muted py-4">
                    <i class="fas fa-check-circle fa-2x mb-3 d-block"></i>
                    No completed transactions
                </td>
            </tr>
        `;
        return;
    }
    
    // Create table rows with proper structure for scrollable table
    tbody.innerHTML = transactions.map(transaction => {
        const statusBadge = transaction.status === 'success' 
            ? `<span class="badge bg-success"><i class="fas fa-check me-1"></i>${transaction.status}</span>`
            : transaction.status === 'failure'
            ? `<span class="badge bg-danger"><i class="fas fa-times me-1"></i>${transaction.status}</span>`
            : `<span class="badge bg-warning">${transaction.status}</span>`;
            
        const callbackBadge = transaction.callback_received
            ? `<span class="badge bg-success"><i class="fas fa-check me-1"></i>Yes</span>`
            : `<span class="badge bg-secondary"><i class="fas fa-times me-1"></i>No</span>`;
            
        return `
            <tr>
                <td>${transaction.order_id}</td>
                <td>$${transaction.amount}</td>
                <td><span class="badge bg-info">${transaction.payment_instrument.type}</span></td>
                <td><span class="badge bg-secondary">${transaction.selected_gateway}</span></td>
                <td>${statusBadge}</td>
                <td>${callbackBadge}</td>
                <td>${new Date(transaction.updated_at).toLocaleString()}</td>
            </tr>
        `;
    }).join('');
    
    // Ensure the table container maintains scrollable behavior
    const tableContainer = tbody.closest('.table-responsive');
    if (tableContainer) {
        tableContainer.style.maxHeight = '400px';
        tableContainer.style.overflowY = 'auto';
        tableContainer.style.overflowX = 'auto';
        
        // Ensure the parent card is not scrollable
        const card = tableContainer.closest('.card');
        if (card) {
            card.style.overflow = 'visible';
        }
        
        // Re-apply sticky headers after content update
        const thead = tableContainer.querySelector('thead');
        if (thead) {
            thead.style.position = 'sticky';
            thead.style.top = '0';
            thead.style.zIndex = '100';
            
            const thElements = thead.querySelectorAll('th');
            thElements.forEach(th => {
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.zIndex = '100';
                th.style.backgroundColor = '#212529';
                th.style.color = 'white';
            });
        }
    }
}

// Update gateway cards
function updateGatewayCards(gateways) {
    // Find the gateway cards container - it's the first card-body with a row
    const gatewayCardsContainer = document.querySelector('.card-body .row');
    
    if (!gatewayCardsContainer) {
        console.error('Gateway cards container not found');
        return;
    }
    
    const gatewayCardsHTML = Object.entries(gateways).map(([gatewayName, gateway]) => {
        const isHealthy = gateway.is_healthy;
        const healthClass = isHealthy ? 'gateway-healthy' : 'gateway-unhealthy';
        const statusBadgeClass = isHealthy ? 'bg-success' : 'bg-danger';
        const statusIcon = isHealthy ? 'fas fa-check-circle' : 'fas fa-times-circle';
        const statusText = isHealthy ? 'Healthy' : 'Unhealthy';
        const successRatePercentage = Math.round(gateway.success_rate * 100);
        
        return `
            <div class="col-md-4 mb-3">
                <div class="card gateway-card ${healthClass}">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start mb-3">
                            <h5 class="card-title mb-0">
                                <i class="fas fa-credit-card me-2"></i>
                                ${gatewayName}
                            </h5>
                            <span class="badge ${statusBadgeClass} status-badge">
                                <i class="${statusIcon} me-1"></i>${statusText}
                            </span>
                        </div>
                        
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${gateway.weight}%</div>
                                <div class="stat-label">Weight</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${successRatePercentage}%</div>
                                <div class="stat-label">Success Rate</div>
                            </div>
                        </div>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${gateway.total_requests}</div>
                                <div class="stat-label">Total Recent Requests</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${gateway.recent_success_callbacks || 0}</div>
                                <div class="stat-label">Recent Success Callbacks</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${gateway.recent_failure_callbacks || 0}</div>
                                <div class="stat-label">Recent Failure Callbacks</div>
                            </div>
                        </div>
                        
                        ${gateway.disabled_until ? `
                        <div class="alert alert-warning mt-2 mb-0">
                            <small>
                                <i class="fas fa-clock me-1"></i>
                                Disabled until: ${new Date(gateway.disabled_until).toLocaleString()}
                            </small>
                        </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    gatewayCardsContainer.innerHTML = gatewayCardsHTML;
}

// Auto-refresh tables every 5 seconds
setInterval(refreshTables, 5000);

// Initialize scrollable tables
function initializeScrollableTables() {
    const tableContainers = document.querySelectorAll('.table-responsive');
    tableContainers.forEach(container => {
        // Ensure only the table container is scrollable, not the card
        container.style.maxHeight = '400px';
        container.style.overflowY = 'auto';
        container.style.overflowX = 'auto';
        
        // Ensure the parent card is not scrollable
        const card = container.closest('.card');
        if (card) {
            card.style.overflow = 'visible';
        }
        
        // Ensure sticky headers are properly set
        const thead = container.querySelector('thead');
        if (thead) {
            thead.style.position = 'sticky';
            thead.style.top = '0';
            thead.style.zIndex = '100';
            
            // Set sticky positioning for each th element
            const thElements = thead.querySelectorAll('th');
            thElements.forEach(th => {
                th.style.position = 'sticky';
                th.style.top = '0';
                th.style.zIndex = '100';
                th.style.backgroundColor = '#212529';
                th.style.color = 'white';
            });
        }
    });
}

// Initial load
document.addEventListener('DOMContentLoaded', function() {
    // Initialize scrollable tables
    initializeScrollableTables();
    
    // Apply sticky headers
    applyStickyHeaders();
    
    // Initial refresh of all data
    refreshTables();
    
    // Initialize response area
    const responseArea = document.getElementById('responseArea');
    const responsePlaceholder = document.getElementById('responsePlaceholder');
    
    if (responseArea && responsePlaceholder) {
        responseArea.style.display = 'none';
        responsePlaceholder.style.display = 'block';
        responsePlaceholder.innerHTML = `
            <i class="fas fa-arrow-left fa-2x mb-3"></i>
            <p>Response will appear here after initiating a transaction</p>
        `;
    }
    
    // Set default order ID
    const orderIdField = document.getElementById('orderId');
    if (orderIdField) {
        orderIdField.value = generateUniqueOrderId();
    }
    
    // Add event delegation for callback buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('callback-btn') || e.target.closest('.callback-btn')) {
            const button = e.target.classList.contains('callback-btn') ? e.target : e.target.closest('.callback-btn');
            const orderId = button.getAttribute('data-order-id');
            const status = button.getAttribute('data-status');
            const gateway = button.getAttribute('data-gateway');
            
            triggerCallback(orderId, status, gateway);
        }
    });
});
</script> 